#!/usr/bin/env python
import os
import sys
from os.path import join, isfile, abspath, dirname, relpath, isdir
import shutil
import pip
from pip.req import parse_requirements


def err(msg=''):
    sys.stderr.write(msg + '\n')
    

def init(name, package_name, setup_py_fpath, kwargs=None):
    if is_installing():
        print('Upgrading pip and setuptools...')
        try:
            pip.main(['install', '--upgrade', 'setuptools', 'pip'])
        except StandardError:
            err('Cannot update pip and setuptools, that might cause errors during the following intallation')

    if abspath(dirname(setup_py_fpath)) != abspath(os.getcwd()):
        sys.stderr.write('Please, change to ' + dirname(setup_py_fpath) + ' before running setup.py\n')
        sys.exit()

    cmd = [a for a in sys.argv if not a.startswith('-')][-1]
    if cmd == 'tag':
        version = write_version_py(package_name, kwargs=kwargs)
        run_cmdl('git tag -a %s -m "Version %s"' % (version, version))
        run_cmdl('git push --tags')
        sys.exit()

    if cmd == 'publish':
        run_cmdl('python setup.py sdist upload')
        # _run('python setup.py bdist_wheel upload')
        sys.exit()

    if cmd == 'up':
        run_cmdl('git pull --recurse-submodules --rebase')
        # if first time: $ git submodule update --init --recursive
        run_cmdl('git submodule foreach "(git checkout master; git pull --rebase)"')
        sys.exit()

    if cmd == 'clean':
        clean_package(package_name, '.')
        sys.exit()

    if is_installing():
        version = write_version_py(package_name, kwargs=kwargs)
        print('Installing ' + name + ((' version ' + str(version)) if version else ''))
        print('')
        return version


def clean_package(package_name, dirpath='.'):
    print('Cleaning up binary, build and dist for ' + package_name + ' in ' + dirpath + '...')
    if isdir(join(dirpath, 'build')):
        shutil.rmtree(join(dirpath, 'build'))
    if isdir(join(dirpath, 'dist')):
        shutil.rmtree(join(dirpath, 'dist'))
    if isdir(join(dirpath, package_name + '.egg-info')):
        shutil.rmtree(join(dirpath, package_name + '.egg-info'))
    print('Done.')


def get_reqs():
    try:
        install_reqs = parse_requirements('requirements.txt', session=False)
    except TypeError:
        install_reqs = parse_requirements('requirements.txt')
    reqs = [str(ir.req) for ir in install_reqs if ir.req]
    return reqs


def find_package_files(dirpath, package, skip_exts=None):
    paths = []
    for (path, dirs, fnames) in os.walk(join(package, dirpath)):
        for fname in fnames:
            if skip_exts and any(fname.endswith(ext) for ext in skip_exts):
                continue
            fpath = join(path, fname)
            paths.append(relpath(fpath, package))
    return paths


''' Versioning:
1. Write each version to VERSION.txt
2. If the changes are significant, tag the release and push the new tag:
   $ python setup.py tag '''
def write_version_py(package_name, kwargs=None):
    version_txt = 'VERSION.txt'
    if not isfile(version_txt):
        return None

    with open(version_txt) as f:
        v = f.read().strip().split('\n')[0]

    try:
        import subprocess
        git_revision = subprocess.check_output(['git', 'rev-parse', '--short', 'HEAD']).rstrip()
    except:
        git_revision = ''
        pass

    version_py = os.path.join(package_name, 'version.py')
    with open(version_py, 'w') as f:
        f.write((
            '# Do not edit this file, pipeline versioning is governed by git tags\n' +
            '__version__ = \'' + v + '\'\n' +
            '__git_revision__ = \'' + str(git_revision) + '\'') + '\n')
        if kwargs:
            for k, v in kwargs.items():
                f.write(k + ' = \'' + v + '\'\n')
    return v


def run_cmdl(_cmd):
    print('$ ' + _cmd)
    os.system(_cmd)


def is_installing():
    cmd = [a for a in sys.argv if not a.startswith('-')][-1]
    return cmd not in ['tag', 'up', 'clean']


def is_cleaning():
    cmd = [a for a in sys.argv if not a.startswith('-')][-1]
    return cmd in ['clean']


def compile_tool(tool_name, dirpath, requirements):
    if not all(isfile(join(dirpath, req)) for req in requirements):
        print('Compiling ' + tool_name)
        run_cmdl('make -C ' + dirpath)
        if not all(isfile(join(dirpath, req)) for req in requirements):
            err('Failed to compile ' + tool_name + ' (' + dirpath + ')\n')
            return False
    return True
